<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Документация CVM</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <header>
        <h1>SOSA Binary Bytecode Specification <span class="version-badge">v1.0</span></h1>
        <p>Official documentation for the Simple Optimized Strict Architecture binary bytecode format</p>
    </header>

    <main>
        <section id="overview">
            <h2 class="section-title">Overview</h2>
            <p>This document defines the binary format for the SOSA bytecode.</p>

            <div class="alert">
                <strong>Note:</strong> This specification applies to SOSA (Simple Optimized Strict Architecture) version
                1.0.0. Future versions will use backward compatibility principles.
            </div>
        </section>

        <section id="file-structure">
            <h2 class="section-title">Main principles of SOSA bytecode</h2>
            <p>A SOSA bytecode file uses those rules:</p>
            <ol>
                <li>
                    <strong>Hexadecimal Format</strong><br>
                    Bytes separated by spaces (<code>01 A3 С3</code>). <br>
                    Multi-byte values: big-endian (<code>01 02</code>
                    = 258).
                </li>
                <li>
                    <strong>Header</strong><br>
                    Block in the top of file. File always starts with header. It has MAGIC code, Version Info, Constant
                    pool size and reserved
                    bytes (for future features).
                </li>
                <li>
                    <strong>CODE</strong><br>
                    Block after Header, that contains the executable bytecode instructions. <br>
                    Every instuction has specification, that shows its bytecode, count of arguments and type of
                    arguments.
                </li>
            </ol>
        </section>

        <section id="header">
            <h2 class="section-title">Header Format</h2>
            <p>Every valid CVM bytecode file begins with a header that identifies the file and provides version
                information:</p>

            <table>
                <thead>
                    <tr>
                        <th>Position</th>
                        <th>Size (bytes)</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>0</td>
                        <td>4</td>
                        <td>Magic bytes: <code>83 79 83 65</code> ("SOSA" in ASCII)</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>2</td>
                        <td>Major version</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>2</td>
                        <td>Minor version</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>2</td>
                        <td>Patch version</td>
                    </tr>
                    <tr>
                        <td>10</td>
                        <td>4</td>
                        <td>Constant pool size in bytes</td>
                    </tr>
                    <tr>
                        <td>14</td>
                        <td>20</td>
                        <td>Reserved for future use. There should only be zero bytes.</td>
                    </tr>
                </tbody>
            </table>
            <p>
                After the header (which totals 34 bytes), the constant pool occupies the next
                <em>Constant pool size</em> bytes in the file. The code section (instructions) starts
                immediately after the constant pool ends.
            </p>
        </section>

        <section id="instructions">
            <h2 class="section-title">Instructions info</h2>
            <p>Each instruction has its own set of argument conditions. Thus, the first byte of an instruction is its
                opcode. The second is the type of instruction. The next N bytes are the arguments needed by this type of
                instruction. If istruction has zero arguments in type 00, it must have zero arguments in each type.
            </p>
            <div class="example">
                <strong>Example</strong>
                <pre>
Load for integer:
Opcode:      00 (load)
Type:        00 (immediate value)
Arguments:   4-byte integer
            
Load for Constant(it is only example):
Opcode:      00 (load)
Type:        01 (constant reference)
Arguments:   2-byte reference
                </pre>
            </div>
            <h4>Table of commands for type 00:</h4>
            <table>
                <thead>
                    <tr>
                        <th>Opcode</th>
                        <th>Instruction</th>
                        <th>Description</th>
                        <th>Argument Count for</th>
                        <th>Argument Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>0</td>
                        <td>ld</td>
                        <td>Load value to stack</td>
                        <td>1</td>
                        <td>4 bytes integer</td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>add</td>
                        <td>Addition</td>
                        <td>0</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>sub</td>
                        <td>Subtraction</td>
                        <td>0</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>mul</td>
                        <td>Multiplication</td>
                        <td>0</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>div</td>
                        <td>Division</td>
                        <td>0</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>log</td>
                        <td>Log value</td>
                        <td>0</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>debug</td>
                        <td>Debug instruction</td>
                        <td>0</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>7-127</td>
                        <td>-</td>
                        <td>Reserved for additional instructions</td>
                        <td>-</td>
                        <td>-</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="constant-pool">
            <h2 class="section-title">Constant Pool Layout</h2>
            <p>
                The constant pool immediately follows the 34-byte header. Its size is specified
                by the field at position 10 in the header. The constant pool is used for:
            </p>
            <ul>
                <li>Storing immutable values (e.g., string literals, numeric constants)</li>
                <li>Referencing methods, classes, or other symbolic data</li>
            </ul>
        </section>

        <section id="enhancements">
            <h2 class="section-title">Enhancements for Function Calls and Data Management</h2>

            <h3>Stack Frames</h3>
            <p>
                To support function calls, the virtual machine uses stack frames. Each function call pushes
                a new stack frame onto the call stack. A frame typically includes:
            </p>
            <ul>
                <li>
                    <strong>Return Address:</strong> The instruction pointer location to return to once the
                    function completes.
                </li>
                <li>
                    <strong>Local Variables Array Pointer:</strong> A reference to the array of local variables
                    allocated for this function call.
                </li>
                <li>
                    <strong>Saved Context:</strong> Any registers or additional execution context needed to
                    restore the caller’s state.
                </li>
            </ul>
            <p>
                These frames are allocated at runtime; the bytecode file itself does not store them. However,
                they are critical for correctly interpreting function call boundaries during execution.
            </p>

            <h3>Local Variables Array</h3>
            <p>
                Each stack frame has an associated local variables array, which is allocated upon function
                entry. This array contains:
            </p>
            <ul>
                <li>Function parameters, as passed by the caller</li>
                <li>Temporary values or intermediate results during execution</li>
                <li>Possible space for additional bookkeeping needed by the function</li>
            </ul>
            <p>
                Instructions that reference local variables will include an index (e.g.,
                <code>LV index</code>) to read or write a particular slot in this array. The size of the
                local variables array is either declared in the function metadata or allocated dynamically based
                on the maximum number of local variables required.
            </p>

            <h3>Constant Pool (Runtime Access)</h3>
            <p>
                During runtime, certain instructions (such as <code>load</code> with a type specifying “constant
                reference”) will look up literals or symbolic references in the constant pool by index or offset.
                This allows the bytecode to keep code and data separate and reuse constants efficiently.
            </p>
        </section>
    </main>
</body>

</html>